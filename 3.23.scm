#lang sicp
(define deq (cons (cons '() '()) (cons '() '())))
(define (make-deque) (cons 0 deq))
(define (forehead deque) (car (cdr deque)))
(define (reversed deque) (cdr (cdr deque)))
(define (counter deque) (car deque))
(define (counter+ deque) (set-car! deque (+ (counter deque) 1)))
(define (counter- deque) (set-car! deque (- (counter deque) 1)))
(define (empty-deque? deque) (eq? (counter deque) 0))
(define (first store) (car store))
(define (last store) (cdr store))

(define (select-forehead selector deque) (selector (forehead deque)))
(define (select-reversed selector deque) (selector (reversed deque)))
(define (first-forehead deque) (select-forehead first deque))
(define (last-forehead deque) (select-forehead last deque))
(define (first-reversed deque) (select-reversed first deque))
(define (last-reversed deque) (select-reversed last deque))

!!!!!!(define (empty-deque-insert! deque item) присвоэння хвоста store ыы
  (let ((forehead-item (cons item '()))
        (reversed-item (cons item '())))
        (set-front! (forehead deque)
    (set-car! (cdr deque) forehead-store)
    (set-cdr! (cdr deque) reversed-store)
    (set-car! deque 1))
  deque)

(define (set-front! store item) (set-car! store (cons item (first store))))
(define (set-rear! store item)
  (let ((new-pair (cons item '())))
    (set-cdr! (last store) new-pair)
    (set-cdr! store new-pair)))

(define (front-insert-d! deque item)
      (set-front! (forehead deque) item)
      (set-rear! (reversed deque) item)
  (counter+ deque)
  deque)

(define (front-insert-deque! deque item)
  (if (empty-deque? deque)
      (empty-deque-insert! deque item)
      (front-insert-d! deque item)))
(define (rear-insert-d! deque item)
  (set-rear! (forehead deque) item)
  (set-front! (reversed deque) item)
  (counter+ deque)
  deque)
(define (rear-insert-deque! deque item)
  (if (empty-deque? deque)
      (empty-deque-insert! deque item)
      (rear-insert-d! deque item)))
(define (front-delete-deque! deque)
  (if (eq? counter 0)
      (error "empty deque")
      (let ((deleted (car (forehead deque))))
        (set-car! (cdr deque) (cdr (forehead deque)))
        deleted)))

(define (rear-delete-deque! deque)
  (if (eq? counter 0)
      (error "empty deque")
      (let ((deleted (car (reversed deque))))
        (set-cdr! (cdr deque) (cdr (reversed deque)))
        deleted)))
(define x (make-deque))
x
(front-insert-deque! x '5)
 (cdr (last (reversed x)))
(front-insert-deque! x '10)
(rear-insert-deque! x '15)
(rear-insert-deque! x '20)